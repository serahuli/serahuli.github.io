---
title: 图解《HTTP》学习
top: false
cover: false
toc: true
mathjax: true
date: 2020-09-28 15:02:47
password:
summary:
tags: 'HTTP'
categories: '计算机网络'
toc_max_depth: 6
toc_min_depth: 1
---

## **Web** 及网络基础 

### 使用 **HTTP** 协议访问 **Web** 

​	在网页浏览器（Web browser）的地址栏中输入 URL ,Web 页面如何呈现

> Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议 ）的协议作为规范，完成（客户端和服务端）通信流程。

![image-20200924202033786](1.1客户端服务端通信.png)

- URL： Uniform Resource Locator，统一资源定位符

- SGML： Standard Generalized Markup Language，标准通用标记语言

- HTML：HyperText Markup Language，超文本标记语言

- URI：Uniform Resource Identifier，统一资源标识符

- URN： URI的历史名字， **U**niform **R**esource **N**ame

  ![image-20200924203922034](URL-URI-URN.png)

### 网络基础 **TCP/IP** 

> 通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。 

#### **TCP/IP** 协议族

![image-20200924205208400](协议族.png)

​						**TCP/IP** 是互联网相关的各类协议族的总称

> 把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。 

#### **TCP/IP** 的分层管理 

> TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。

层次化好处：如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了

<u>**TCP/IP 协议族各层的作用**</u>

- 应用层 

  > 应用层决定了向用户提供应用服务时通信的活动。
  >
  > TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File 
  >
  > Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。

- 传输层

  > 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 
  >
  > 在传输层有两个性质不同的协议：TCP（Transmission Control 
  >
  > Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。

- 网络层（又名网络互连层） 

  > 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。 
  >
  > 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 

- 链路层（又名数据链路层，网络接口层） 

  > 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。 

#### **TCP/IP** 通信传输流

![image-20200924210312606](TCP:IP通信.png)

发送端从应用层往下走，接收端则往应用层上走。

- 发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。 
- 在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 
- 网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。
- 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。 

![image-20200924210759549](http请求-展示页面.png)

> 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。 =>> 封装（encapsulate）

###  IP、TCP 和 DNS 

#### 负责传输的 **IP** 协议

> IP（Internet Protocol）网际协议位于网络层。
>
> IP 协议的作用是把各种数据包传送给对方。

- IP 地址： 指明了节点被分配到的地址

- MAC地址（Media Access Control Address）： 指网卡所属的固定 

  地址

> IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。 

> 使用 **ARP** 协议凭借 **MAC** 地址进行通信

ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

![image-20200924214818908](ARP协议.png)

#### 确保可靠性的 **TCP** 协议

TCP 位于传输层，提供可靠的字节流服务

> 字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

TCP 协议采用了三次握手（three-way handshaking）策略

> 握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize）和ACK（acknowledgement）。 

![image-20200924215759259](三次握手.png)

> 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后,回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。 

### 负责域名解析的 **DNS** 服务 

​		DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。 

> DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 

![image-20200924220335484](域名解析.png)

### 各种协议与 **HTTP** 协议的关系 

![image-20200924220541251](请求全过程示意图.png)

### **URI** 和 **URL**

统一资源标识符： URI、Uniform Resource Identifier

**Uniform**：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文 环境来识别资源指定的访问方式。如： http:或 ftp:

**Resource**： 资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例 如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。

**Identifier**：可标识的对象。也称为标识符。 

**URI 就是由某个协议方案表示的资源的定位标识符。协议 方案是指访问资源所使用的协议类型名称。 **

> URI 用字符串标识某一互联网资源，而 URL表示资源的地点, URL是 URI 的子集。

####  **URI** 格式 

> 表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如`/image/logo.gif`。 

![image-20200924221406588](绝对URI.png)

- 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。
- 登录信息(认证): 指定用户名和密码作为从服务器端获取资源时必要的登录信息(身份认证)。此项是可选项。 
- 服务器地址: 使用绝对 `URI` 必须指定待访问的服务器地址。地址可以是类似`hackr.jp` 这种 `DNS` 可解析的名称，或是 `192.168.1.1` 这类 `IPv4` 地址 名，还可以是` [0:0:0:0:0:0:0:1] `这样用方括号括起来的` IPv6 `地址名。 
- 服务器端口号 : 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。 
- 带层次的文件路径: 指定服务器上的文件路径来定位特指的资源。
- 查询字符串: 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。
- 片段标识符: 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。 

---

## 简单的 **HTTP** 协议 

### **HTTP** 协议 

**HTTP** 协议用于客户端和服务器端之间 的通信 

- 请求访问文本或图像等资源的一端称为客户端
- 提供资源响应的一端称为服务器端。

> 请求必定由客户端发出，而服务器端回复响应

![image-20200925115528797](客户端服务端通信.png)

> 请求报文中的内容:
>
> ```txt
> GET /index.htm HTTP/1.1
> Host: hackr.jp
> ```
>
> - `GET`表示请求访问服务器的类型，称为方法 
> - `/index.htm` 指明了请求访问的资源对象, 也叫做请求 `URI（request-URI）`
> - `HTTP/1.1`，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。 

​		请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。

![image-20200925115852997](请求报文.png)

​		接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。

> 响应内容：
>
> ```txt
> HTTP/1.1 200 OK
> Date: Tue, 10 Jul 2012 06:50:15 GMT
> Content-Length: 362
> Content-Type: text/html
> <html>
> ……
> ```
>
> - ` HTTP/1.1`表示服务器对应的 `HTTP`版本
> - `200 OK` 表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。
> - 创建响应的日期时间，是首部字段（header field）内的一个属性。 
> - 接着以一空行分隔，之后的内容称为资源实体的主体（entity body）

​		响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

![image-20200925123924929](响应报文.png)

​		HTTP 是一种不保存状态，即无状态（stateless）协议。在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。 	**HTTP** 协议自身不具备保存之前发送过的请求或响应的功能 ===> 确保协议的可伸缩性

> HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术

​		**HTTP** 协议使用 **URI** 让客户端定位到资源

> 当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。指定请求 URI 的方式有很多。
>
> - ![image-20200925143832574](指定请求URI.png)
>
> 如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI。

---

### 告知服务器意图的 **HTTP** 方法

- **GET** ：获取资源

  ![image-20200925150001048](get请求.png)

- **POST**：传输实体主体 

  ![image-20200925150020631](post方法.png)

- **PUT**：传输文件

  > PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。 

  ![image-20200925150513613](PUT方法.png)

- **HEAD**：获得报文首部

  > HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 

  ![image-20200925151535866](HEAD方法.png)

- **DELETE**： 删除文件 

  > DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。 HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。 

  ![image-20200925151829395](DELETE方法.png)

- **OPTIONS**：询问支持的方法 

  > OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

  ![image-20200925152411782](OPTIONS方法.png)

- **TRACE**：追踪路径

  > TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。

  > 容易引发 `XST（Cross-Site Tracing，跨站追踪）`攻击

  ![image-20200925155234638](TRACE方法.png)

- **CONNECT**：要求用隧道协议连接代理 

  > CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接 层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。 
  >
  > ```txt
  > CONNECT 代理服务器名:端口号 HTTP版本
  > ```

  ![image-20200925155459958](CONNECT方法.png)

向请求 URI 指定的资源发送请求报文时，采用称为**方法的命令**。

![image-20200925161441259](HTTP支持的方法.png)

---

### **持久连接节省通信量**

> HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。

![image-20200925161734608](TCP三次连接四次挥手.png) 

> 浏览器浏览一个包含多张图片的 HTML页面时，在发送请求访问 HTML页面资源的同时，也会请求该 HTML页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。 

![image-20200925163259558](TCP非持久连接的缺点.png)

#### 持久连接 

> 为解决上述 `TCP` 连接的问题，`HTTP/1.1` 和一部分的 `HTTP/1.0` 想出了持久连接（`HTTP Persistent Connections`，也称为 `HTTP keep-alive` 或 `HTTP connection reuse`）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态

![image-20200925171026600](持久连接.png)

> 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。 

#### 管线化 

> 持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待 响应了。 

![image-20200925171759807](管线化.png)

---

### 使用 **Cookie** 的状态管理

> HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。 

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

>  Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

> 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。

- 没有 **Cookie** 信息状态下的请求

  ![image-20200925173525411](没有cookie信息状态下的请求.png)

- 第 **2** 次以后（存有 **Cookie** 信息状态）的请求 

  ![image-20200925173555179](第2次以后（存有Cookie信息状态）的请求.png)

1. 请求报文（没有 **Cookie** 信息的状态)

   ```txt
   GET /reader/ HTTP/1.1
   Host: hackr.jp
   首部字段内没有Cookie的相关信息
   ```

2. 响应报文（服务器端生成 **Cookie** 信息） 

   ```txt
   HTTP/1.1 200 OK
   Date: Thu, 12 Jul 2012 07:12:20 GMT
   Server: Apache 
   ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT＞ 
   Content-Type: text/plain; charset=UTF-8
   ```

3. 请求报文（自动发送保存着的 **Cookie** 信息） 

   ```txt
   GET /image/ HTTP/1.1
   Host: hackr.jp
   Cookie: sid=1342077140226724
   ```

---

## **HTTP** 报文内的 **HTTP**信息

> HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。

### **HTTP** 报文

> - 用于 HTTP 协议交互的信息被称为 HTTP 报文。
> - 请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。 
> - HTTP 报文本身是由多行(用 CR+LF 作换行符)数据构成的字符串文本。
> - HTTP 报文大致可分为报文首部和报文主体(不一定有)两块。

![image-20200927100611130](http报文结果.png)

图： 请求报文结构

![image-20200927100701308](请求报文结构.png)

图： 请求报文结构

![image-20200927100821984](请求报文实例.png)

图： 请求报文实例

![image-20200927100910079](响应报文结构.png)

图： 响应报文结构

![image-20200927100958443](响应报文实例.png)

图： 响应报文实例

**首部字段**

1. 请求行: 包含用于请求的方法，请求 URI 和 HTTP 版本

2. 状态行 :  包含表明响应结果的状态码，原因短语和 HTTP 版本。

3. 首部字段:  包含表示请求和响应的各种条件和属性的各类首部。

   - 通用首部

     > 请求报文和响应报文两方都会使用的首部

   - 请求首部

     > 从客户端向服务器端发送请求报文时使用的首部

   - 响应首部

     > 从服务器端向客户端返回响应报文时使用的首部

   - 实体首部

     > 针对请求报文和响应报文实体部分使用的首部

   - 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

首部字段详解

|   实体首部字段   |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
|      Allow       | 用于通知客户端能够支持Request-URI指定资源的所有HTTP方法 当服务器接收到不支持的HTTP方法时,会以状态码405 Method Not Allowed返回 |
| Content-Encoding | 告知客户端服务器对实体的主题部分选用的内容编码格式 内容编码指在不丢失实体信息的前提下进行的压缩 |
| Content-Language |                 告知客户端实体主体使用的语言                 |
|  Content-Length  |                     表明实体主体部分大小                     |
| Content-Location |                  报文主体返回资源对应的URI                   |
|   Content-MD5    | 目的在于检查报文主体在传输过程中是否保持完整,以及确认传输到达 |
|  Content-Range   |      告知客户端作为响应返回的实体的哪个部分符合范围请求      |
|   Content-Type   |                 说明实体主体内对象的媒体类型                 |
|     Expires      |                  将资源失效的日期告知客户端                  |
|  Last-Modified   |                    指明资源最终修改的时间                    |

 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

---

### 编码提升传输速率

> HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。 

#### 报文主体和实体主体的差异 

- 报文（**message**）

  是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。

- 实体（**entity**） 

  作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

  

>  HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 

#### 压缩传输的内容编码 

内容编码： 内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压·					缩。内容编码后的实体由客户端接收并负责解码。

![image-20200927111937100](内容编码.png)

常用的内容编码： 

- **gzip**（**GNU zip**）
- **compress**（**UNIX** 系统的标准压缩） 
- **deflate**（**zlib**） 
- **identity**（不进行编码）

#### 分割发送的分块传输编码

> 在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

![image-20200927113233916](分块传输编码.png)

> - 分块传输编码会将实体主体分成多个部分(块)。每一块都会用十六进制来标记块的大小,而实体主体的最后一块会使用“0(CR+LF)”来标记。
>
> - 使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编 码前的实体主体。 
>
> - HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可 以在通信时按某种编码方式传输，但只定义作用于分块传输编码中

---

### 发送多种数据的多部分对象集合 

> 发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明,就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一 种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的 数据。 

HTTP 协议中也采纳多部分对象集合，发送的一份报文主体内可含有多类型实体。

多部分对象集合包含的对象:

- **multipart/form-data** : 在 Web 表单文件上传时使用。
- **multipart/byteranges** : 状态码 206（Partial Content，部分内容）响应报文包含了多个范 围的内容时使用。 

> - 在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。
> - 使用 boundary 字符串来划分多部分对象集合指明的各类实体。
> - 在 boundary 字符串指定的各个实体的起始行之前插入“--”标记
> - 在多部分对象集合对 应的字符串的最后插入“--”标记
> - 多部分对象集合的每个部分类型中，都可以含有首部字段。

---

### 获取部分内容的范围请求 

可恢复的机制： 解决问题 =》 下载大图或者视频在下载过程中遇到网络中断的情况，那就必须重头开始。 =》 要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。 

![image-20200927115143303](范围请求.png)

图： 范围请求

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。

byte 范围的指定形式如下： 

- **5001~10 000** 字节 ： Range: bytes=5001-10000 

- 从 **5001** 字节之后全部的： Range: bytes=5001- 

- 从一开始到 **3000** 字节和 **5000~7000** 字节的多重范围 ： 

  Range: bytes=-3000, 5000-7000 

范围请求响应会返回状态码为 206 Partial Content 的响应报文，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。

### 内容协商返回最合适的内容 

**内容协商（Content Negotiation）**

![image-20200927115515397](内容协商作用.png)

> 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

包含在请求报文中的某些首部字段（如下）就是判断的基准.

- **Accept** 
- **Accept-Charset**
- **Accept-Encoding** 
- **Accept-Language**
- **Content-Language** 

**内容协商技术有以下 3 种类型**:

- 服务器驱动协商（**Server-driven Negotiation**）

  > 由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自 动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。 

- 客户端驱动协商（**Agent-driven Negotiation**）

  > 由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。 

- 透明协商（**Transparent Negotiation**） 

  > 是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

## **HTTP** 状态码

> HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。

![image-20200928173246411](状态码表示返回的信息.png)

状态码以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。

![image-20200928173428480](状态码类别.png)

### **2XX** 成功 

2XX 的响应结果表明请求被正常处理了

#### **200 OK** 

![200](200ok.png)

#### **204 No Content** 

![204](204.png)

> 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如,当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 

#### **206 Partial Content** 

![206](206范围请求.png)

> 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

### **3XX** 重定向 

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

#### **301 Moved Permanently** 

![image-20200928193611941](301永久重定向.png)

> 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 

#### **302 Found** 

![image-20200928194816105](302.png)

> 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。只是临时性的，比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。 

#### **303 See Other**

![image-20200928195048859](303.png)

> 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 **GET**方法定向获取请求的资源。 

#### **304 Not Modified** 

![image-20200929100358018](304.png)

> 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

**307 Temporary Redirect**

临时重定向。

### **4XX** 客户端错误 

4XX 的响应结果表明客户端是发生错误的原因所在。

#### **400 Bad Request** 

![image-20200929101043394](400.png)

#### **401 Unauthorized** 

![image-20200929101225969](401.png)

> 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 

#### **403 Forbidden**

![image-20200929101653917](403.png)

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。

#### **404 Not Found** 

![image-20200929101754404](404.png)

该状态码表明服务器上无法找到请求的资源。

### **5XX** 服务器错误

5XX 的响应结果表明服务器本身发生错误

#### **500 Internal Server Error** 

![image-20200929102010801](500.png)

服务器端在执行请求时发生了错误 ---》 **找服务端解决**

#### **503 Service Unavailable**

![image-20200929102124530](503.png)

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## **Web** 服务器

一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。 

### 用单台虚拟主机实现多个域名 

![image-20200929103635653](DNS解析域名.png)

> 在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。 

### 通信数据转发程序

**代理**是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。 

**网关**是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。

**隧道**是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

#### 代理

![image-20200929110047532](代理服务器.png)

​		持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。 每次通过代理服务器转发请求或响应时，会追加写入 **Via** 首 部信息 。

> 使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。 

**代理使用方法**

- 缓存代理：代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
- 透明代理： 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 

#### 网关

![image-20200929110529685](网关.png)

​		利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。网关能使通信线路上的服务器提供非 HTTP 协议服务。 

#### 隧道

![image-20200929110724740](隧道.png)

​		隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。 

### 保存资源的缓存 

​		缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 缓存服务器是代理服务器的一种，并归类在缓存代理类型中。

![image-20200929111035961](缓存服务器.png)

> 优势在于利用缓存可避免多次从源服务器转发资源。

#### 缓存的有效期限

​		即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

![image-20200929111158039](缓存服务器有效期.png)

#### 客户端的缓存 

浏览器缓存：存在客户端浏览器（本地磁盘），有效则直接使用，过期重新请求

![image-20200929111342644](客户端缓存.png)

